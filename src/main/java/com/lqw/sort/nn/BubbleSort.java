package com.lqw.sort.nn;

import com.lqw.sort.Sortable;

/**
 * 冒泡排序,
 * 每一个元素都只和后面一个元素进行比较并进行排序（注意是只和后面一个元素，不会和其他元素）
 * 所以每一轮循环之后，都会将未排序中最大的元素排到对应位置。
 * 这个操作就像是冒泡一样，所以叫做冒泡排序
 * <p>
 * <p>
 * 最好时间复杂度:O(n);可以通过添加标记，如果某次遍历没有进行交换，则表明全部有序
 * 最坏时间复杂度:O(n*n)
 * 平均时间复杂度:O(n*n)
 */
public class BubbleSort implements Sortable {

    public void sort(int[] arr) {

        for (int i = 0; i < arr.length; i++) {
            //每一回都是前一位数字和后一位数字进行比较，
            // 如果前面的数大于后面的数，则将两个数字换位置
            // 如果一个数字是最大的，那么他每次都会和后面的数字交换，最终移动到最后面的位置
            // 如果一个数字不是最大的，那么他会一直交换直到遇到第一个比他大的数字，然后他自身停留在这个位置，比他大的那个数字向后交换，一直重复这个操作
            // 因此每次循环之后必定有一个数字排到了正确位置，位置进行了交换，如果某一次循环之后发现没有进行过位置交换则认为已经排序完毕，可以结束循环了。
            for (int j = 0; j < arr.length-1; j++) {
                if(arr[j]>arr[j+1]){
                    int v=arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1]=v;
                }
            }
            print(arr);
        }

    }

}
